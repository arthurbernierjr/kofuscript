// Generated by MambaScript 0.4.2 
var present = console.log; 
// Generated by MambaScript 0.4.2 
var buildRule, buildRules, LONG_FLAG, MULTI_FLAG, normalizeArguments, OPTIONAL, OptionParser, SHORT_FLAG;
exports.OptionParser = OptionParser = function () {
  function OptionParser(rules, param$) {
    this.banner = param$;
    this.rules = buildRules(rules);
  }
  OptionParser.prototype.parse = function (args) {
    var arg, i, isOption, matchedRule, options, rule, value;
    options = {
      'arguments': [],
      literals: []
    };
    args = normalizeArguments(args);
    for (var i$ = 0, length$ = args.length; i$ < length$; ++i$) {
      arg = args[i$];
      i = i$;
      if (arg === '--') {
        options.literals = args.slice(i + 1);
        break;
      }
      isOption = !!(arg.match(LONG_FLAG) || arg.match(SHORT_FLAG));
      matchedRule = false;
      for (var i$1 = 0, length$1 = this.rules.length; i$1 < length$1; ++i$1) {
        rule = this.rules[i$1];
        if (rule.shortFlag === arg || rule.longFlag === arg) {
          value = rule.hasArgument ? args[i += 1] : true;
          options[rule.name] = rule.isList ? (options[rule.name] || []).concat(value) : value;
          matchedRule = true;
          break;
        }
      }
      if (isOption && !matchedRule)
        throw new Error('unrecognized option: ' + arg);
      if (!isOption) {
        options['arguments'] = args.slice(i);
        break;
      }
    }
    return options;
  };
  OptionParser.prototype.help = function () {
    var letPart, lines, rule, spaces;
    lines = [];
    if (this.banner)
      lines.unshift('' + this.banner + '\n');
    for (var i$ = 0, length$ = this.rules.length; i$ < length$; ++i$) {
      rule = this.rules[i$];
      spaces = 15 - rule.longFlag.length;
      spaces = spaces > 0 ? Array(spaces + 1).join(' ') : '';
      letPart = rule.shortFlag ? rule.shortFlag + ', ' : '    ';
      lines.push('  ' + letPart + rule.longFlag + spaces + rule.description);
    }
    return '\n' + lines.join('\n') + '\n';
  };
  return OptionParser;
}();
LONG_FLAG = /^(--\w[\w\-]+)/;
SHORT_FLAG = /^(-\w)/;
MULTI_FLAG = /^-(\w{2,})/;
OPTIONAL = /\[(\w+(\*?))\]/;
buildRules = function (rules) {
  var tuple;
  return function (accum$) {
    for (var i$ = 0, length$ = rules.length; i$ < length$; ++i$) {
      tuple = rules[i$];
      if (tuple.length < 3)
        tuple.unshift(null);
      accum$.push(buildRule.apply(null, [].slice.call(tuple)));
    }
    return accum$;
  }.call(this, []);
};
buildRule = function (shortFlag, longFlag, description, options) {
  var match;
  if (null == options)
    options = {};
  match = longFlag.match(OPTIONAL);
  longFlag = longFlag.match(LONG_FLAG)[1];
  return {
    name: longFlag.substr(2),
    shortFlag: shortFlag,
    longFlag: longFlag,
    description: description,
    hasArgument: !!(match && match[1]),
    isList: !!(match && match[2])
  };
};
normalizeArguments = function (args) {
  var arg, l, match, result;
  args = args.slice(0);
  result = [];
  for (var i$ = 0, length$ = args.length; i$ < length$; ++i$) {
    arg = args[i$];
    if (match = arg.match(MULTI_FLAG)) {
      for (var cache$ = match[1].split(''), i$1 = 0, length$1 = cache$.length; i$1 < length$1; ++i$1) {
        l = cache$[i$1];
        result.push('-' + l);
      }
    } else {
      result.push(arg);
    }
  }
  return result;
};
