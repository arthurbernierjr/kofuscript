// Generated by MambaScript 0.5.1 
var present = console.log; 
// Generated by MambaScript 0.5.1 
var _, checkType, checkTypeAnnotation, correctExtends, CS, debug, formatType, ImplicitAny, isAcceptable, isAcceptableExtends, isAcceptableFunctionType, isAcceptablePrimitiveSymbol, isAcceptableStruct, reporter, typeErrorText, util, util;
debug = require('./helpers').debug;
util = require('util');
reporter = require('./reporter');
CS = require('./nodes');
_ = require('lodash');
ImplicitAny = require('./types').ImplicitAny;
correctExtends = function (scope, annotation) {
  var cur, extendList, next;
  extendList = [annotation];
  cur = annotation;
  while (null != (null != cur && null != cur.heritages ? cur.heritages.extend : void 0)) {
    next = scope.getTypeByNode(cur.heritages.extend);
    if (next) {
      extendList.push(next);
      cur = next;
    } else {
      break;
    }
  }
  return extendList;
};
isAcceptableExtends = function (scope, left, right) {
  return _.some(correctExtends(scope, left).map(function (le) {
    return le.identifier.typeRef === right.identifier.typeRef;
  }));
};
isAcceptablePrimitiveSymbol = function (scope, left, right, nullable, isArray) {
  if (null == nullable)
    nullable = false;
  if (null == isArray)
    isArray = false;
  if (left.nodeType !== 'primitiveIdentifier')
    throw 'left is not primitive';
  if (left.identifier.typeRef === 'Any')
    return true;
  if (!isAcceptableExtends(scope, left, right)) {
    if (nullable && (right.identifier.typeRef === 'Null' || right.identifier.typeRef === 'Undefined'))
      return true;
    return false;
  }
  if (!!left.identifier.isArray) {
    if (null != (null != right && null != right.identifier ? right.identifier.isArray : void 0)) {
      if (!!(null != right && null != right.identifier ? right.identifier.isArray : void 0) !== true) {
        return false;
      }
    } else {
      return false;
    }
  } else if (!!(null != right && null != right.identifier ? right.identifier.isArray : void 0) !== false) {
    return false;
  }
  return true;
};
isAcceptableStruct = function (scope, left, right) {
  return _.every(left.properties.map(function (lprop, n) {
    var rprop;
    rprop = _.find(right.properties, function (rp) {
      return (null != rp.identifier ? rp.identifier.typeRef : void 0) === (null != lprop.identifier ? lprop.identifier.typeRef : void 0);
    });
    if (!(null != rprop))
      return null != lprop.typeAnnotation && null != lprop.typeAnnotation.identifier ? lprop.typeAnnotation.identifier.nullable : void 0;
    return isAcceptable(scope, lprop.typeAnnotation, rprop.typeAnnotation);
  }));
};
isAcceptableFunctionType = function (scope, left, right) {
  var passArgs;
  if (null != left.returnType)
    left.returnType;
  else
    left.returnType = ImplicitAny;
  if (null != right.returnType)
    right.returnType;
  else
    right.returnType = ImplicitAny;
  passArgs = _.every(left['arguments'].map(function (leftArg, n) {
    var rightArg;
    leftArg = null != leftArg ? leftArg : ImplicitAny;
    rightArg = null != right['arguments'][n] ? right['arguments'][n] : ImplicitAny;
    return isAcceptable(scope, leftArg, rightArg);
  }));
  if (!passArgs)
    return false;
  if ((null != right.returnType && null != right.returnType.identifier ? right.returnType.identifier.typeRef : void 0) === 'Void')
    return true;
  if ((null != left.returnType && null != left.returnType.identifier ? left.returnType.identifier.typeRef : void 0) === 'Void')
    return true;
  return isAcceptable(scope, left.returnType, right.returnType);
};
isAcceptable = function (scope, left, right) {
  var cache$, isSameArrayFlag, leftAnnotation, leftNullable, leftWholeNullable, ret, rightAnnotation, rightNullable;
  if (!(null != left) || !(null != right))
    return true;
  cache$ = [
    left,
    right
  ].map(function (node) {
    var resolveType;
    resolveType = require('./type-resolver').resolveType;
    return resolveType(scope, node);
  });
  leftAnnotation = cache$[0];
  rightAnnotation = cache$[1];
  if (null != leftAnnotation.identifier && null != leftAnnotation.identifier.identifier && null != leftAnnotation.identifier.identifier.typeArguments ? leftAnnotation.identifier.identifier.typeArguments.length : void 0)
    console.error(leftAnnotation.identifier.identifier.typeArguments);
  if (!(null != leftAnnotation) || !(null != rightAnnotation))
    return true;
  if (leftAnnotation.nodeType === 'primitiveIdentifier')
    if (leftAnnotation.identifier.typeRef === 'Any') {
      return true;
    }
  if (left.identifier && right.identifier && rightAnnotation) {
    leftWholeNullable = left.identifier.wholeNullable;
    if (leftWholeNullable && (rightAnnotation.identifier.typeRef === 'Undefined' || rightAnnotation.identifier.typeRef === 'Null'))
      return true;
    isSameArrayFlag = !!left.identifier.isArray === !!right.identifier.isArray || !!left.identifier.isArray === !!rightAnnotation.isArray;
    if (!isSameArrayFlag)
      return false;
  }
  if (leftAnnotation.nodeType === 'identifier') {
    if (leftAnnotation.identifier.typeRef === rightAnnotation.identifier.typeRef) {
      return true;
    } else {
      return false;
    }
  } else if (leftAnnotation.nodeType === 'members') {
    if (rightAnnotation.nodeType === 'members') {
      ret = isAcceptableStruct(scope, leftAnnotation, rightAnnotation);
      return ret;
    } else {
      return false;
    }
  }
  if (leftAnnotation.nodeType === 'primitiveIdentifier')
    if (rightAnnotation.nodeType === 'primitiveIdentifier') {
      if (leftAnnotation.identifier.typeRef === 'Void')
        return true;
      leftNullable = !!left.identifier.nullable;
      rightNullable = !!right.identifier.nullable;
      if (!leftNullable && rightNullable)
        return false;
      return isAcceptablePrimitiveSymbol(scope, leftAnnotation, rightAnnotation, leftNullable);
    } else {
      return false;
    }
  if (leftAnnotation.nodeType === 'functionType')
    if (rightAnnotation.nodeType === 'functionType') {
      return isAcceptableFunctionType(scope, leftAnnotation, rightAnnotation);
    } else if (null != leftAnnotation && null != leftAnnotation.returnType ? leftAnnotation.returnType.implicit : void 0) {
      return true;
    } else {
      return false;
    }
  return true;
};
util = require('util');
formatType = function (node, prefix) {
  var args, array, joined, lines, returnType;
  if (null == prefix)
    prefix = '';
  if (node.nodeType === 'members') {
    lines = node.properties.map(function (prop) {
      return prefix + '- ' + formatType(prop, prefix + '  ');
    });
    return '[struct]' + '\n' + lines.join('\n');
  } else if (node.nodeType === 'primitiveIdentifier') {
    return prefix + node.identifier.typeRef;
  } else if (node.nodeType === 'identifier') {
    array = node.identifier.isArray ? '[]' : '';
    if (null != node.typeAnnotation) {
      return node.identifier.typeRef + array + ' :: ' + formatType(node.typeAnnotation, prefix);
    } else {
      return node.identifier.typeRef + array;
    }
  } else if (node.nodeType === 'functionType') {
    args = node['arguments'].map(function (arg) {
      return prefix + '- ' + formatType(arg, prefix + '  ');
    });
    joined = '\n' + args.join('\n');
    returnType = formatType(node.returnType, prefix + '  ');
    return '[function]\n' + prefix + '[arguments] ' + joined + '\n' + prefix + '[return] ' + returnType + '';
  } else {
    return util.inspect(node, false, null);
  }
};
typeErrorText = function (left, right) {
  var header, l, r;
  header = '\nTypeError:';
  l = formatType(left, '  ');
  r = formatType(right, '  ');
  return '' + header + '\nrequired:\n' + l + '\nassignee:\n' + r + '';
};
checkType = function (scope, node, left, right) {
  var err, ret;
  ret = isAcceptable(scope, left.typeAnnotation, right.typeAnnotation);
  if (ret) {
    return true;
  } else {
    err = typeErrorText(left.typeAnnotation, right.typeAnnotation);
    if (left.implicit && right.implicit) {
      reporter.add_warning(node, err);
    } else {
      reporter.add_error(node, err);
    }
    return false;
  }
};
checkTypeAnnotation = function (scope, node, left, right) {
  var err, ret;
  ret = isAcceptable(scope, left, right);
  if (ret) {
    return true;
  } else {
    err = typeErrorText(left, right);
    if (left.implicit && right.implicit) {
      reporter.add_warning(node, err);
    } else {
      reporter.add_error(node, err);
    }
    return false;
  }
};
module.exports = {
  checkType: checkType,
  checkTypeAnnotation: checkTypeAnnotation,
  isAcceptable: isAcceptable
};
